plugins {
    id 'org.jetbrains.kotlin.jvm' version '2.1.10'
    id 'org.openapi.generator' version '6.6.0'
}

group = 'com.benlukka.THEIA'
version = '1.0-SNAPSHOT'

def http4kVersion = "5.4.0.0"

repositories {
    mavenCentral()
}

dependencies {
    testImplementation 'org.jetbrains.kotlin:kotlin-test'
    implementation("org.http4k:http4k-client-fuel:${http4kVersion}")
    implementation("org.http4k:http4k-client-websocket:${http4kVersion}")
    implementation("org.http4k:http4k-contract:${http4kVersion}")
    implementation("org.http4k:http4k-core:${http4kVersion}")
    implementation("org.http4k:http4k-format-jackson:${http4kVersion}")
    implementation("org.http4k:http4k-multipart:${http4kVersion}")
    implementation("org.http4k:http4k-opentelemetry:${http4kVersion}")
    implementation("org.http4k:http4k-server-undertow:${http4kVersion}")
    implementation("org.http4k:http4k-template-handlebars:${http4kVersion}")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0")
    implementation("ch.qos.logback:logback-classic:1.5.18")
}

// Task to generate the OpenAPI spec to a file
tasks.register('generateSpecFile', JavaExec) {
    group = "openapi"
    description = "Generates OpenAPI specification to a file"
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'com.benlukka.theia.MainKt'
    args = ['generateSpecToFile', "$projectDir/build/openapi/swagger.json"]

    doFirst {
        mkdir "$projectDir/build/openapi"
    }
}

tasks.register('cleanGenerated', Delete) {
    delete "$projectDir/frontend/src/generated"
}

// Configure the OpenAPI generator task
openApiGenerate {
    generatorName = "typescript-fetch"
    outputDir = "$projectDir/frontend/generated"
    // Use the file generated by the generateSpecFile task
    inputSpec = "$projectDir/src/main/resources/spec.json"
    typeMappings = [
            DateTime: "string",
            Date: "string"
    ]
    configOptions = [
            supportsES6: "true",
            enumPropertyNaming: "UPPERCASE"
    ]
}

// Task dependencies
tasks.openApiGenerate.dependsOn(tasks.cleanGenerated, tasks.generateSpecFile)

import java.util.concurrent.atomic.AtomicReference

def frontendProcess = new AtomicReference<Process>()
tasks.register('run') {
    group = 'application'
    description = 'Runs the server after building the frontend'

    doLast {
        // Create logs directory if it doesn't exist
        def logsDir = file('logs')
        if (!logsDir.exists()) {
            logsDir.mkdirs()
        }

        // Create log files with timestamps
        def timestamp = new java.text.SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(new Date())
        def frontendLogFile = new File(logsDir, "frontend-${timestamp}.log")
        def backendLogFile = new File(logsDir, "backend-${timestamp}.log")

        println "Starting frontend and backend processes..."
        println "Logs will be written to: ${logsDir.absolutePath}"
        println "Frontend log: ${frontendLogFile.name}"
        println "Backend log: ${backendLogFile.name}"

        // Start frontend process with tee-like logging
        def frontend = new ProcessBuilder(['yarn', 'start'])
                .directory(file('frontend'))
                .redirectErrorStream(true)  // Merge stdout and stderr
                .start()

        // Start backend process with tee-like logging
        def backend = new ProcessBuilder(['java', '-cp', sourceSets.main.runtimeClasspath.asPath, 'com.benlukka.theia.MainKt'])
                .redirectErrorStream(true)  // Merge stdout and stderr
                .start()

        // Create streams for reading process output and writing to logs
        def frontendOutputStream = frontend.getInputStream()
        def backendOutputStream = backend.getInputStream()

        // Create a thread to handle frontend output
        Thread frontendLogThread = new Thread({
            def frontendWriter = new PrintWriter(new FileWriter(frontendLogFile, true))
            try {
                def reader = new BufferedReader(new InputStreamReader(frontendOutputStream))
                String line
                while ((line = reader.readLine()) != null) {
                    println "[FRONTEND] ${line}"
                    frontendWriter.println(line)
                    frontendWriter.flush()
                }
            } catch (IOException e) {
                e.printStackTrace()
            } finally {
                frontendWriter.close()
            }
        })

        // Create a thread to handle backend output
        Thread backendLogThread = new Thread({
            def backendWriter = new PrintWriter(new FileWriter(backendLogFile, true))
            try {
                def reader = new BufferedReader(new InputStreamReader(backendOutputStream))
                String line
                while ((line = reader.readLine()) != null) {
                    println "[BACKEND] ${line}"
                    backendWriter.println(line)
                    backendWriter.flush()
                }
            } catch (IOException e) {
                e.printStackTrace()
            } finally {
                backendWriter.close()
            }
        })

        // Start the log threads
        frontendLogThread.start()
        backendLogThread.start()

        // Shutdown hook to kill both processes on Ctrl+C
        Runtime.runtime.addShutdownHook(new Thread({
            println "Shutting down processes..."
            frontend.destroy()
            backend.destroy()
            // Give time for log threads to finish
            Thread.sleep(500)
        }))

        // Wait for both to finish
        backend.waitFor()
        frontend.waitFor()

        // Wait for log threads to finish
        frontendLogThread.join()
        backendLogThread.join()
    }
}
tasks.register('dev') {
    dependsOn(':frontend:yarnStart')
    group = 'application'
    description = 'Runs the server in development mode'

    doLast {
        javaexec {
            mainClass = 'com.benlukka.theia.MainKt'
            classpath = sourceSets.main.runtimeClasspath
            jvmArgs = ['-Ddev=true']
        }
    }
}

test {
    useJUnitPlatform()
}

kotlin {
    jvmToolchain(23)
}